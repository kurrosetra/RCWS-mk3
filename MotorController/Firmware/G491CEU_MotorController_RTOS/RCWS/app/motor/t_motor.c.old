/*
 * motor.c
 *
 *  Created on: May 25, 2022
 *      Author: 62812
 */

#include <stdio.h>
#include <stdlib.h>

#include "t_motor.h"
#include "driver/hal_motor/hal_motor.h"
#include "config/rws_config.h"

#include "iwdg.h"

#if DEBUG_MOTOR==1
/*** Internal Const Values, Macros ***/
#	define LOG(str, ...) printf("[%ld TMtr:%d] " str, (osKernelSysTick()%10000UL), __LINE__, ##__VA_ARGS__)
#	define LOG_E(str, ...) printf("[TMtr_Err:%d] " str, __LINE__, ##__VA_ARGS__)
#else
#	define LOG(str, ...)
#	define LOG_E(str, ...)
#endif	//if DEBUG_MOTOR==1

static Motor_t motor;

#define is_motor_az_enable()	((motor.enable & MTR_AZ_ENABLE) == MTR_AZ_ENABLE)
#define is_motor_el_enable()	((motor.enable & MTR_EL_ENABLE) == MTR_EL_ENABLE)

typedef enum
{
	timer_used_by_none,
	timer_used_by_init,
	timer_used_by_homing,
	timer_used_by_gsl,
} Timer_user_e;
Timer_user_e tim_user = timer_used_by_none;
uint8_t g_timer_in_used = 0;
uint32_t g_init_timeout = 0;

static void mtr_send_to_bus();
static uint8_t mtr_set_power(Motor_t *mtr);
static int32_t _man_pan_speed_to_c(int32_t speed);
static int32_t _man_tilt_speed_to_c(int32_t speed);
static void _stop_timer();

void tim_motor_callback(void const *argument)
{
	/* USER CODE BEGIN tim_motor_callback */
	g_timer_in_used = 1;
	if (tim_user == timer_used_by_init) {
		if (osKernelSysTick() < g_init_timeout)
			/* send notif to task manager that this thread is still running */
			osMessagePut(opt_get_queue(Q_MANAGER_NOTIF), T_Motor_id, 0);
	}
	else {
		_stop_timer();
	}
}

static void _stop_timer()
{
	osTimerStop(mtr_get_timer(Tim_Motor_id));
	g_timer_in_used = 0;
	tim_user = timer_used_by_none;
}

static void t_motor_init(const uint32_t delay)
{
	osDelay(delay);
	motor.pan_state.pos = motor.tilt_state.pos = 0;

	tim_user = timer_used_by_init;
	g_init_timeout = osKernelSysTick() + MTR_INIT_TIMEOUT;
	osTimerStart(mtr_get_timer(Tim_Motor_id), 500);
	while (hal_motor_init(motor.enable) != HAL_OK) {
		LOG_E("motor init failed!\r\n");
		osDelay(10);
	}
	_stop_timer();
}

void t_motor(void const *argument)
{
	/* USER CODE BEGIN t_motor */
	static uint16_t _dbg_send_mtr_cmd_counter = 0;
	LOG("Created!\r\n");

	osMutexWait(mtr_get_mutex(Mutex_Motor_id), osWaitForever);
	/* TODO Select which motor to be activated */
	motor.enable = 0;
	motor.enable |= MTR_AZ_ENABLE;
	motor.enable |= MTR_EL_ENABLE;

	t_motor_init(3000);
	osMutexRelease(mtr_get_mutex(Mutex_Motor_id));

	/* Infinite loop */
	uint32_t _mtr_send_timer = osKernelSysTick() + 150;
	uint32_t _bus_send_timer = osKernelSysTick() + 100;
	uint32_t _bus_recv_timestamp = 0;
	uint8_t gsl_start = 0;
	for ( ;; ) {
		int32_t _p, _t;
		float _fp, _ft;

		/* get message from the queue */
		osEvent event = osMailGet(mtr_get_mail(T_Motor_id), 10);
		if (event.status == osEventMail) {
			/* create buffer pointer to hold queue value */
			MAIL_Motor_t *pRMail;
			pRMail = event.value.p;

			Motor_Sender_Id_e sender = pRMail->sender_id;
			switch (sender)
			{
			case Motor_Sender_Bus_Mode_id:
				LOG("st= %02X\r\n", *(uint8_t* )&pRMail->param.command.mode);
				motor.pan_command.power_enable = motor.tilt_command.power_enable = pRMail->param.command.mode.motorEnable;
				/* TODO select mode active */
				*(uint8_t*) &motor.mode_command = *(uint8_t*) &pRMail->param.command.mode;
				if (*(uint8_t*) &motor.mode_command != *(uint8_t*) &motor.mode_state) {
					if(motor.mode_command.moveMode==MOVE_MODE_OPS_ACTIVE){
						if(motor.mode_command.opsMode==OPS_MODE_GSL){
							/* TODO enable gsl task */

						}
					}
					*(uint8_t*) &motor.mode_state = *(uint8_t*) &motor.mode_command;
				}

				_bus_recv_timestamp = osKernelSysTick();
				break;
			case Motor_Sender_Bus_Command_Speed_id:
				_p = pRMail->param.command.value.pan;
				_t = pRMail->param.command.value.tilt;
				LOG("recv man= %ld,%ld\r\n", _p, _t);

				if (motor.mode_state.moveMode == MOVE_MODE_MAN) {
					if (motor.pan_command.power_enable != 0) {
						if (abs(_p) < 100)
							_p = 0;
						motor.pan_command.spd_man_in_c = _man_pan_speed_to_c(_p);
					}
					else
						motor.pan_command.spd_man_in_c = 0;

					if (motor.tilt_command.power_enable != 0) {
						if (abs(_t) < 100)
							_p = 0;
						motor.tilt_command.spd_man_in_c = _man_tilt_speed_to_c(_t);
					}
					else
						motor.tilt_command.spd_man_in_c = 0;

					LOG("in c= %ld,%ld\r\n", motor.pan_command.spd_man_in_c, motor.tilt_command.spd_man_in_c);
				}
				else {
					motor.pan_command.spd_man_in_c = 0;
					motor.tilt_command.spd_man_in_c = 0;
				}
				_bus_recv_timestamp = osKernelSysTick();
				break;
			case Motor_Sender_Bus_Command_Gsl_id:
				if (motor.mode_state.moveMode == MOVE_MODE_OPS_ACTIVE && motor.mode_state.opsMode == OPS_MODE_GSL) {
					/* TODO send command to gsl task */
					if (gsl_start == 0) {
						_p = motor.pan_state.pos;
						_t = motor.tilt_state.pos;
						_fp = (float) pRMail->param.command.value.pan / 1000;
						_ft = (float) pRMail->param.command.value.tilt / 1000;

						LOG("recv gsl=%.3f,%.3f\r\n", _fp, _ft);
						if (_fp > 180.0f)
							_fp -= 360.0f;
						motor.pan_command.pos_gsl_in_c = RWS_MOTOR_PAN_DEG_TO_C(_fp) + _p;

						gsl_start = 1;
					}
				}
				break;
			default:
				break;
			}

			/* free memory allocated for mail */
			osMailFree(mtr_get_mail(T_Motor_id), pRMail);
		}

		hal_motor_get_motor_state(&motor.pan_state, &motor.tilt_state);

		if ((_bus_recv_timestamp > 0) && (osKernelSysTick() >= (_bus_recv_timestamp + BUS_MAX_TIMEOUT))) {
			_bus_recv_timestamp = 0;

			motor.pan_command.power_enable = 0;
			motor.pan_command.spd_man_in_c = 0;
			motor.pan_command.spd_trk_in_c = 0;
			motor.pan_command.pos_bal_in_c = 0;
			motor.pan_command.pos_gsl_in_c = 0;

			motor.tilt_command.power_enable = 0;
			motor.tilt_command.spd_man_in_c = 0;
			motor.tilt_command.spd_trk_in_c = 0;
			motor.tilt_command.pos_bal_in_c = 0;
			motor.tilt_command.pos_gsl_in_c = 0;
			LOG("\r\n\r\n\r\n\r\n");
		}

		if (osKernelSysTick() >= _mtr_send_timer) {
			_mtr_send_timer = osKernelSysTick() + 10;

			mtr_set_power(&motor);
			_dbg_send_mtr_cmd_counter += hal_motor_set_speed(motor.pan_command.spd_man_in_c,
					motor.tilt_command.spd_man_in_c);
		}

		if (osKernelSysTick() >= _bus_send_timer) {
			_bus_send_timer = osKernelSysTick() + 100;

			mtr_send_to_bus();
			LOG("pan state=%X,%X\r\n", _dbg_send_mtr_cmd_counter, motor.pan_state.statusword);
			_dbg_send_mtr_cmd_counter = 0;
		}

		/* send notif to task manager that this thread is still running */
		osMessagePut(opt_get_queue(Q_MANAGER_NOTIF), T_Motor_id, 0);
	}
	/* USER CODE END t_motor */
}

static uint8_t mtr_set_power(Motor_t *mtr)
{
	uint8_t ret = 0;

	if (is_motor_az_enable()) {
		if (mtr->pan_command.power_enable != mtr->pan_state.power) {
			mtr->pan_state.power = mtr->pan_command.power_enable;
			hal_motor_set_pan_power(mtr->pan_state.power);
			ret |= MTR_AZ_ENABLE;
		}
	}

	if (is_motor_el_enable()) {
		if (mtr->tilt_command.power_enable != mtr->tilt_state.power) {
			mtr->tilt_state.power = mtr->tilt_command.power_enable;
			hal_motor_set_tilt_power(mtr->tilt_state.power);
			ret |= MTR_EL_ENABLE;
		}
	}

	return ret;
}

static void mtr_send_to_bus()
{
	/* ================ */
	/* send motor state */
	/* ================ */
	Body_motor_mode_t _mode;
	Body_motor_status_t _pan_state;
	Body_motor_status_t _tilt_state;
	MAIL_Bus_t *state_mail;

	*(uint8_t*) &_mode = 0;
	*(uint8_t*) &_pan_state = 0;
	*(uint8_t*) &_tilt_state = 0;

	/* allocate memory; receiver must be free it */
	state_mail = osMailAlloc(mtr_get_mail(T_Bus_id), 0);
	state_mail->sender_id = Bus_Sender_Motor_State_id;
	state_mail->param.motor.mode = _mode;
	state_mail->param.motor.pan_state = _pan_state;
	state_mail->param.motor.tilt_state = _tilt_state;

	/* send mail queue*/
	osMailPut(mtr_get_mail(T_Bus_id), state_mail);

	/* =================== */
	/* send motor position */
	/* =================== */
	MAIL_Bus_t *pos_mail;

	/* allocate memory; receiver must be free it */
	pos_mail = osMailAlloc(mtr_get_mail(T_Bus_id), 0);
	pos_mail->sender_id = Bus_Sender_Motor_Position_id;
	pos_mail->param.motor.position.pan = motor.pan_state.pos;
	pos_mail->param.motor.position.tilt = motor.tilt_state.pos;

	LOG("PT= %ld,%ld\r\n", pos_mail->param.motor.position.pan, pos_mail->param.motor.position.tilt);

	/* send mail queue*/
	osMailPut(mtr_get_mail(T_Bus_id), pos_mail);
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

static int32_t mtr_speed_to_c(int32_t x, int32_t in_min, int32_t in_max, int32_t out_min, int32_t out_max)
{
	int64_t atas = ((int64_t) x - in_min) * ((int64_t) out_max - out_min);
	int32_t bawah = in_max - in_min;

	if (bawah > 0)
		return (uint32_t) ((atas / bawah) + out_min);

	return 1;
}

/* mapping max_command(1000000) to RWS_MOTOR_PAN_MAX_SPEED(100000) */
static int32_t _man_pan_speed_to_c(int32_t speed)
{
	return mtr_speed_to_c(speed, -1000000, 1000000, -RWS_MOTOR_PAN_MAX_SPEED, RWS_MOTOR_PAN_MAX_SPEED);
}

/* mapping max_command(1000000) to RWS_MOTOR_TILT_MAX_SPEED (172032L) */
static int32_t _man_tilt_speed_to_c(int32_t speed)
{
	return mtr_speed_to_c(speed, -1000000L, 1000000L, -RWS_MOTOR_TILT_MAX_SPEED, RWS_MOTOR_TILT_MAX_SPEED);
}
